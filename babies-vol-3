1. обьект - король типов джаваскрипта.
 инициализировать обект можна разными способами

можна использовать литерал доя этого просто пишешь курли брасес - и обект готов,
можно использовать конструктор который создаст иснтанс обекта
а можно использовать статический метод коеструктора create - который принимает аргументом другой обект который устанавливается в качестве прототипа нового обекта. безумно полезный метод на основе которого раньге базировались классы, и наследование.

2 напонимаю что обект является сложным типом данных, и никак не может сраниваться по значению, потому что при присваивании какого-то объекта в переменную, мы записываем не сам обект а просто референцию на место в памяти.

обекту можно добавлять сколько угодно методов - тоесть ключей в которых храниться референция на фенкцию
и проперти - тоесть ключей в которых храниться информация любогу другого типа

так же можно и удалять свойства из обекта - для этого нужно испотзовать оператор delete

eще один способ добавления пропери или метода в обект являются два статические методы конструктора Object.defineProperty и Object.defineProperties 

3 а что если мы хотим узнать иммет ли какой-то обект провепрти или метод. можно для этого просто обратиться через точку по этому имени, и мы получим результат если под таким ключем хотя бы что-то храниться, но никогда не стоит забывать о наследовании. на этом примере видно что у обекта можно вызвать метод тустринг который является фенкцией, хотя конечно такого ключа нащ обект не имеет - он его унаследовал от родителей. поэтому никогда не стоит забывать о проверке hasOwnProperty.

4. проверять имеет ли обект какой либо ключ путем обращения к имени через точку не совсем безопасно - тут пример у еас есть фенкция getValue которая возвращает свой аргумент, и мы записываем результат выполнения в обект как значение ключа. но по ошибке забыли вызвать с аргументом, в результате чего фенкиця вернет нам undefined что и будет записано в как vflue ключа.в этом случае не очень понятно действительно нет такого ключа у обекта или ключ есть но его значение undefined. более безопасно проверять с помощью оператора in.

5.а что делать в случае если у нас ключ обекта имеет значение которое просто нельзя вписать после точки, наприсер строка с знаками пунктуации просто обратившист через точку мы получим ексепшен. в этом случае используется доступ через квадратные скобки, и в ковычках подается сам ключ. так же квадратные скобки используются в случае если мы не знаем значение ключа - оно у нас определенно какой-то переменной.

6. колейны смешек от джаваскрипта. помните я говорил что имя переменной не может быть зарезервированым словом? это не работает для обектов. ключ люекта может быть и ретурном и сдассом и даже войдом.

7. а как можно проиетрировать обект? самым быстрым но не самым надежным способом есть цикл фор ин
имеет вот такой синтаксис, при итерации в консоле мы получим три лога 

8. не совсем надежный потому что он не умеет распозновать собственные свойства и унаследованые.
вот тут я создал обект second, с помощью статического метода create - еще раз напоманаю как он работает - он создает обект, и устанавливает второй аргумент в качестве прото только что созданому. и если мы просто проиерируем обект secon циклом фор ин - то увидем не толкьо собственный ключ second1 а увидем еще и ключи первого обекта. поэтому нкогда не стоит забывать о проверке на hasOwnProperty. цикл for of о котором отлично вспомнил дарек в прошлый раз -  который игнорирует унаследованые свойства к сожелению не работает с обектами


9. как работает копирование примитивов в джаваскрипте. у насть есть переменная инишиал мы присваеваем ей значание 4, или любой друой примитив. потом копируем переменную инищиал в переменную копиед теперь у нас есть 4 и ее еопия, поменяв значение в переменной инишиал на 5 мы никак не влияем на значение перемнной копиед. значение инигиал 5 значение копиед по прежденму 4. такое копирование называется копирование по значению.

10. но копирование сложных типов данных работает совергенно по другому. допести у нас есть переменная инишиал и мы записываем в нее референцию на обект(или любой другой комплексный инстанс - массив или фенкция). акцентирую внимание что записываем референцию - потому что обект это часть в памяти. после того как мы присваиваем значение переменной в другую переменную мы присваиваем ссылку на все тот же обект. и в результате модифицирования хоть с помощбю первой референции хоть с помощб. втрой референции мы будет модифицировать обин и тот же обект.

11. довольно часто нам нужно сделать копию обекта, вель мы не хотим каждый раз при модифицировании разных рефернции из разных мест, модифицировать один и тот же обект. сделать копию люекта можно разными спопособами
 наиболее простой - это спред оператор от обекта
 второй способ использовать статический метод обекта assign - работает он так -первм аргументом он принимает обект куда будет копировать свойства, вторым аргументом он принимает обект из которого будут скопированы все перечисляемые свойства.
третий способ - проитерировать обект и записать все его собственные свойста в временную переменную  
такими нехитрыми способами можно создать клон первого уровня. потому что в случае сложного инстансса в обекте все равно будет скопирована референция, а этом случае нужно писать фенкцию которая бует делать копию на каждом из уровней вложености

12 а что дулать в случае если нам нужно получить данные обекта - например все ключи или все значения можно итерировать обект и записывать все во временные переменные. можно но ненужно, потому что для этого есть статические методы конструктора которые сделают все за нас.

первый метод Object.keys - вернет массив всех собственных ключей обекта которые являются энумерал
второй метод Object.getOwnPropertyNames - вернет массив всех собственных ключей обекта
третий метод Object.values - вернет массив всех собственных значений обекта которые являются enumeral
четвертый метод Object.entire - который возвразает массив элементами которого являются массивы элементами которых является пара ключ значение.



